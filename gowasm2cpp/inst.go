// SPDX-License-Identifier: Apache-2.0

package gowasm2cpp

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"golang.org/x/sync/errgroup"
)

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func writeInst(dir string, namespace string, importFuncs, funcs []*wasmFunc, exports []*wasmExport, globals []*wasmGlobal, types []*wasmType, tables [][]uint32) error {
	const groupSize = 64

	var g errgroup.Group
	g.Go(func() error {
		f, err := os.Create(filepath.Join(dir, "inst.h"))
		if err != nil {
			return err
		}
		defer f.Close()

		m := 0
		for _, t := range tables {
			if m < len(t) {
				m = len(t)
			}
		}
		if err := instHTmpl.Execute(f, struct {
			IncludeGuard        string
			Namespace           string
			ImportFuncs         []*wasmFunc
			Exports             []*wasmExport
			Funcs               []*wasmFunc
			Types               []*wasmType
			Globals             []*wasmGlobal
			NumFuncs            int
			NumTable            int
			NumMaxTableElements int
		}{
			IncludeGuard:        includeGuard(namespace),
			Namespace:           namespace,
			ImportFuncs:         importFuncs,
			Exports:             exports,
			Funcs:               funcs,
			Types:               types,
			Globals:             globals,
			NumFuncs:            len(importFuncs) + len(funcs),
			NumTable:            len(tables),
			NumMaxTableElements: m,
		}); err != nil {
			return err
		}
		return nil
	})

	for i := 0; i < (len(funcs)-1)/groupSize+1; i++ {
		i := i
		fs := funcs[groupSize*i : min(groupSize*(i+1), len(funcs))]
		g.Go(func() error {
			f, err := os.Create(filepath.Join(dir, fmt.Sprintf("inst.funcs%d.cpp", i)))
			if err != nil {
				return err
			}
			defer f.Close()

			if err := instFuncCppTmpl.Execute(f, struct {
				Namespace string
				Funcs     []*wasmFunc
			}{
				Namespace: namespace,
				Funcs:     fs,
			}); err != nil {
				return err
			}
			return nil
		})
	}
	g.Go(func() error {
		f, err := os.Create(filepath.Join(dir, "inst.exports.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := instExportsCppTmpl.Execute(f, struct {
			Namespace string
			Exports   []*wasmExport
		}{
			Namespace: namespace,
			Exports:   exports,
		}); err != nil {
			return err
		}
		return nil
	})
	g.Go(func() error {
		f, err := os.Create(filepath.Join(dir, "inst.init.cpp"))
		if err != nil {
			return err
		}
		defer f.Close()

		if err := instInitCppTmpl.Execute(f, struct {
			Namespace   string
			ImportFuncs []*wasmFunc
			Funcs       []*wasmFunc
			Types       []*wasmType
			Tables      [][]uint32
			Globals     []*wasmGlobal
		}{
			Namespace:   namespace,
			ImportFuncs: importFuncs,
			Funcs:       funcs,
			Types:       types,
			Tables:      tables,
			Globals:     globals,
		}); err != nil {
			return err
		}
		return nil
	})
	if err := g.Wait(); err != nil {
		return err
	}
	return nil
}

var instHTmpl = template.Must(template.New("inst.h").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#ifndef {{.IncludeGuard}}
#define {{.IncludeGuard}}

#include <cstdint>

namespace {{.Namespace}} {

class Mem;

class IImport {
public:
  virtual ~IImport();

{{range $value := .ImportFuncs}}{{$value.CppDecl "  "}}

{{end -}} };

class Inst {
public:
  Inst(Mem* mem, IImport* import);

{{range $value := .Exports}}{{$value.CppDecl "  "}}
{{end}}
private:
{{range $value := .Types}}  using Type{{.Index}} = {{.Cpp}};
{{end}}
  union Func {
{{range $value := .Types}}    Type{{.Index}} type{{.Index}}_;
{{end}}  };

{{range $value := .Funcs}}{{$value.CppDecl "  "}}

{{end}}  Mem* mem_;
  IImport* import_;
  Func funcs_[{{.NumFuncs}}];
  uint32_t table_[{{.NumTable}}][{{.NumMaxTableElements}}];

{{range $value := .Globals}}  {{$value.Cpp}}
{{end}}};

}

#endif  // {{.IncludeGuard}}
`))

var instFuncCppTmpl = template.Must(template.New("inst.funcs.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-variable"

#include "autogen/inst.h"

#include <cassert>
#include <cmath>
#include "autogen/bits.h"
#include "autogen/mem.h"

namespace {{.Namespace}} {

{{range $value := .Funcs}}{{$value.CppImpl ""}}
{{end}}}
`))

var instExportsCppTmpl = template.Must(template.New("inst.exports.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "autogen/inst.h"

namespace {{.Namespace}} {

{{range $value := .Exports}}{{$value.CppImpl ""}}
{{end}}}
`))

var instInitCppTmpl = template.Must(template.New("inst.init.cpp").Parse(`// Code generated by go2cpp. DO NOT EDIT.

#include "autogen/inst.h"

namespace {{.Namespace}} {

IImport::~IImport() = default;

Inst::Inst(Mem* mem, IImport* import)
    : mem_{mem},
      import_{import},
      table_{
{{range $value := .Tables}}        { {{- range $value2 := $value}}{{$value2}}, {{end}} },
{{end}}      } {
{{range $value := .ImportFuncs}}  funcs_[{{.Index}}].type0_ = nullptr;
{{end}}{{range $value := .Funcs}}  funcs_[{{.Index}}].type{{.Type.Index}}_ = &Inst::{{.Identifier}};
{{end}}}

}
`))
