// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	"github.com/go-interpreter/wagon/wasm"
	"github.com/pkg/profile"
)

var (
	flagWasm      = flag.String("wasm", "", "WebAssembly file generated by Go")
	flagNamespace = flag.String("namespace", "", "Namespace")
	flagProfile   = flag.Bool("profile", false, "Take profiles")
)

func main() {
	flag.Parse()
	if *flagProfile {
		defer profile.Start().Stop()
	}
	if err := run(); err != nil {
		panic(err)
	}
}

func identifierFromString(str string) string {
	var ident string
	for _, r := range []rune(str) {
		if r > 0xff {
			panic("identifiers cannot include non-Latin1 characters")
		}
		if '0' <= r && r <= '9' {
			ident += string(r)
			continue
		}
		if 'a' <= r && r <= 'z' {
			ident += string(r)
			continue
		}
		if 'A' <= r && r <= 'Z' {
			ident += string(r)
			continue
		}
		ident += fmt.Sprintf("_%02x", r)
	}
	if len(ident) > 512 {
		ident = ident[:511]
	}
	return ident
}

type Func struct {
	Mod     *wasm.Module
	Funcs   []*Func
	Types   []*Type
	Type    *Type
	Wasm    wasm.Function
	Index   int
	Import  bool
	BodyStr string
}

func (f *Func) Identifier() string {
	return identifierFromString(f.Wasm.Name)
}

var funcTmpl = template.Must(template.New("func").Parse(`// OriginalName: {{.OriginalName}}
// Index:        {{.Index}}
{{if .WithBody}}{{if .Public}}public{{else}}private{{end}} {{end}}{{.ReturnType}} {{.Name}}({{.Args}}){{if .WithBody}}
{
{{range .Locals}}    {{.}}
{{end}}{{if .Locals}}
{{end}}{{range .Body}}{{.}}
{{end}}}{{else}};{{end}}`))

func wasmTypeToReturnType(v wasm.ValueType) ReturnType {
	switch v {
	case wasm.ValueTypeI32:
		return ReturnTypeI32
	case wasm.ValueTypeI64:
		return ReturnTypeI64
	case wasm.ValueTypeF32:
		return ReturnTypeF32
	case wasm.ValueTypeF64:
		return ReturnTypeF64
	default:
		panic("not reached")
	}
}

func (f *Func) CSharp(indent string, public bool, withBody bool) (string, error) {
	var retType ReturnType
	switch ts := f.Wasm.Sig.ReturnTypes; len(ts) {
	case 0:
		retType = ReturnTypeVoid
	case 1:
		retType = wasmTypeToReturnType(ts[0])
	default:
		return "", fmt.Errorf("the number of return values must be 0 or 1 but %d", len(ts))
	}

	var args []string
	for i, t := range f.Wasm.Sig.ParamTypes {
		args = append(args, fmt.Sprintf("%s local%d", wasmTypeToReturnType(t).CSharp(), i))
	}

	var locals []string
	var body []string
	if withBody {
		if f.BodyStr != "" {
			body = strings.Split(f.BodyStr, "\n")
		} else if f.Wasm.Body != nil {
			var idx int
			for _, e := range f.Wasm.Body.Locals {
				for i := 0; i < int(e.Count); i++ {
					locals = append(locals, fmt.Sprintf("%s local%d = 0;", wasmTypeToReturnType(e.Type).CSharp(), idx+len(f.Wasm.Sig.ParamTypes)))
					idx++
				}
			}
			var err error
			body, err = f.bodyToCSharp()
			if err != nil {
				return "", err
			}
		} else {
			body = []string{"    throw new NotImplementedException();"}
		}
	}

	var buf bytes.Buffer
	if err := funcTmpl.Execute(&buf, struct {
		OriginalName string
		Name         string
		Index        int
		ReturnType   string
		Args         string
		Locals       []string
		Body         []string
		Public       bool
		WithBody     bool
	}{
		OriginalName: f.Wasm.Name,
		Name:         identifierFromString(f.Wasm.Name),
		Index:        f.Index,
		ReturnType:   retType.CSharp(),
		Args:         strings.Join(args, ", "),
		Locals:       locals,
		Body:         body,
		Public:       public,
		WithBody:     withBody,
	}); err != nil {
		return "", err
	}

	// Add indentations
	var lines []string
	for _, line := range strings.Split(buf.String(), "\n") {
		lines = append(lines, indent+line)
	}
	return strings.Join(lines, "\n") + "\n", nil
}

type Export struct {
	Funcs []*Func
	Index int
	Name  string
}

func (e *Export) CSharp(indent string) (string, error) {
	f := e.Funcs[e.Index]

	var ret string
	var retType ReturnType
	switch ts := f.Wasm.Sig.ReturnTypes; len(ts) {
	case 0:
		retType = ReturnTypeVoid
	case 1:
		ret = "return "
		retType = wasmTypeToReturnType(ts[0])
	default:
		return "", fmt.Errorf("the number of return values must be 0 or 1 but %d", len(ts))
	}

	var args []string
	var argsToPass []string
	for i, t := range f.Wasm.Sig.ParamTypes {
		args = append(args, fmt.Sprintf("%s arg%d", wasmTypeToReturnType(t).CSharp(), i))
		argsToPass = append(argsToPass, fmt.Sprintf("arg%d", i))
	}

	str := fmt.Sprintf(`public %s %s(%s)
{
    %s%s(%s);
}
`, retType.CSharp(), e.Name, strings.Join(args, ", "), ret, identifierFromString(f.Wasm.Name), strings.Join(argsToPass, ", "))

	lines := strings.Split(str, "\n")
	for i := range lines {
		lines[i] = indent + lines[i]
	}
	return strings.Join(lines, "\n"), nil
}

type Global struct {
	Type  wasm.ValueType
	Index int
	Init  int
}

func (g *Global) CSharp(indent string) string {
	return fmt.Sprintf("%sprivate %s global%d = %d;", indent, wasmTypeToReturnType(g.Type).CSharp(), g.Index, g.Init)
}

type Type struct {
	Sig   *wasm.FunctionSig
	Index int
}

func (t *Type) CSharp(indent string) (string, error) {
	var retType ReturnType
	switch ts := t.Sig.ReturnTypes; len(ts) {
	case 0:
		retType = ReturnTypeVoid
	case 1:
		retType = wasmTypeToReturnType(ts[0])
	default:
		return "", fmt.Errorf("the number of return values must be 0 or 1 but %d", len(ts))
	}

	var args []string
	for i, t := range t.Sig.ParamTypes {
		args = append(args, fmt.Sprintf("%s arg%d", wasmTypeToReturnType(t).CSharp(), i))
	}

	return fmt.Sprintf("%sprivate delegate %s Type%d(%s);", indent, retType.CSharp(), t.Index, strings.Join(args, ", ")), nil
}

type Data struct {
	Offset int
	Data   []byte
}

func run() error {
	tmp, err := ioutil.TempDir("", "go2dotnet-")
	if err != nil {
		return err
	}
	defer os.RemoveAll(tmp)

	f, err := os.Open(*flagWasm)
	if err != nil {
		return err
	}
	defer f.Close()

	mod, err := wasm.DecodeModule(f)
	if err != nil {
		return err
	}

	var types []*Type
	for i, e := range mod.Types.Entries {
		e := e
		types = append(types, &Type{
			Sig:   &e,
			Index: i,
		})
	}

	var ifs []*Func
	for i, e := range mod.Import.Entries {
		name := e.FieldName
		ifs = append(ifs, &Func{
			Type: types[e.Type.(wasm.FuncImport).Type],
			Wasm: wasm.Function{
				Sig:  types[e.Type.(wasm.FuncImport).Type].Sig,
				Name: name,
			},
			Index:   i,
			Import:  true,
			BodyStr: importFuncBodies[name],
		})
	}

	// There is a bug that signature and body are shifted (go-interpreter/wagon#190).
	var names wasm.NameMap
	if c := mod.Custom(wasm.CustomSectionName); c != nil {
		var nsec wasm.NameSection
		if err := nsec.UnmarshalWASM(bytes.NewReader(c.Data)); err != nil {
			return err
		}
		if len(nsec.Types[wasm.NameFunction]) > 0 {
			sub, err := nsec.Decode(wasm.NameFunction)
			if err != nil {
				return err
			}
			names = sub.(*wasm.FunctionNames).Names
		}
	}
	var fs []*Func
	for i, t := range mod.Function.Types {
		name := names[uint32(i+len(mod.Import.Entries))]
		body := mod.Code.Bodies[i]
		fs = append(fs, &Func{
			Type: types[t],
			Wasm: wasm.Function{
				Sig:  types[t].Sig,
				Body: &body,
				Name: name,
			},
			Index: i + len(mod.Import.Entries),
		})
	}

	var exports []*Export
	for _, e := range mod.Export.Entries {
		switch e.Kind {
		case wasm.ExternalFunction:
			exports = append(exports, &Export{
				Index: int(e.Index),
				Name:  e.FieldStr,
			})
		case wasm.ExternalMemory:
			// Ignore
		default:
			return fmt.Errorf("export type %d is not implemented", e.Kind)
		}
	}

	allfs := append(ifs, fs...)
	for _, e := range exports {
		e.Funcs = allfs
	}
	for _, f := range ifs {
		f.Mod = mod
		f.Funcs = allfs
		f.Types = types
	}
	for _, f := range fs {
		f.Mod = mod
		f.Funcs = allfs
		f.Types = types
	}

	var globals []*Global
	for i, e := range mod.Global.Globals {
		// TODO: Consider mutability.
		// TODO: Use e.Type.Init.
		globals = append(globals, &Global{
			Type:  e.Type.Type,
			Index: i,
			Init:  0,
		})
	}

	if mod.Start != nil {
		return fmt.Errorf("start section must be nil but not")
	}

	tables := make([][]uint32, len(mod.Table.Entries))
	for _, e := range mod.Elements.Entries {
		v, err := mod.ExecInitExpr(e.Offset)
		if err != nil {
			return err
		}
		offset := v.(int32)
		if diff := int(offset) + int(len(e.Elems)) - int(len(tables[e.Index])); diff > 0 {
			tables[e.Index] = append(tables[e.Index], make([]uint32, diff)...)
		}
		copy(tables[e.Index][offset:], e.Elems)
	}

	var data []Data
	for _, e := range mod.Data.Entries {
		offset, err := mod.ExecInitExpr(e.Offset)
		if err != nil {
			return err
		}
		data = append(data, Data{
			Offset: int(offset.(int32)),
			Data:   e.Data,
		})
	}

	buf := bufio.NewWriterSize(os.Stdout, 1024*1024)
	if err := csTmpl.Execute(buf, struct {
		Namespace   string
		ImportFuncs []*Func
		Funcs       []*Func
		Exports     []*Export
		Globals     []*Global
		Types       []*Type
		Tables      [][]uint32
		InitPageNum int
		Data        []Data
		JS          string
	}{
		Namespace:   *flagNamespace,
		ImportFuncs: ifs,
		Funcs:       fs,
		Exports:     exports,
		Globals:     globals,
		Types:       types,
		Tables:      tables,
		InitPageNum: int(mod.Memory.Entries[0].Limits.Initial),
		Data:        data,
		JS:          js, // defined at js.go
	}); err != nil {
		return err
	}

	if err := buf.Flush(); err != nil {
		return err
	}

	return nil
}

var csTmpl = template.Must(template.New("out.cs").Parse(`// Code generated by go2dotnet. DO NOT EDIT.

#pragma warning disable 162 // unreachable code
#pragma warning disable 164 // label
#pragma warning disable 219 // unused local variables

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Timers;

namespace {{.Namespace}}
{
    sealed class Mem
    {
        const int PageSize = 64 * 1024;

        public Mem()
        {
            this.bytes = new byte[{{.InitPageNum}} * PageSize];
{{range $value := .Data}}            Array.Copy(new byte[] { {{- range $value2 := $value.Data}}{{$value2}},{{end}}}, 0, this.bytes, {{$value.Offset}}, {{len $value.Data}});
{{end}}        }

        internal int Size
        {
            get
            {
                return this.bytes.Length / PageSize;
            }
        }

        internal int Grow(int delta)
        {
            var prevSize = this.Size;
            Array.Resize(ref this.bytes, (prevSize + delta) * PageSize);
            return prevSize;
        }

        internal sbyte LoadInt8(int addr)
        {
            return (sbyte)this.bytes[addr];
        }

        internal byte LoadUint8(int addr)
        {
            return this.bytes[addr];
        }

        internal short LoadInt16(int addr)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    return *(short*)ptr;
                }
            }
        }

        internal ushort LoadUint16(int addr)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    return *(ushort*)ptr;
                }
            }
        }

        internal int LoadInt32(int addr)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    return *(int*)ptr;
                }
            }
        }

        internal uint LoadUint32(int addr)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    return *(uint*)ptr;
                }
            }
        }

        internal long LoadInt64(int addr)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    return *(long*)ptr;
                }
            }
        }

        internal float LoadFloat32(int addr)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    return *(float*)ptr;
                }
            }
        }

        internal double LoadFloat64(int addr)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    return *(double*)ptr;
                }
            }
        }

        internal void StoreInt8(int addr, sbyte val)
        {
            this.bytes[addr] = (byte)val;
        }

        internal void StoreInt16(int addr, short val)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    *(short*)ptr = val;
                }
            }
        }

        internal void StoreInt32(int addr, int val)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    *(int*)ptr = val;
                }
            }
        }

        internal void StoreInt64(int addr, long val)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    *(long*)ptr = val;
                }
            }
        }

        internal void StoreFloat32(int addr, float val)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    *(float*)ptr = val;
                }
            }
        }

        internal void StoreFloat64(int addr, double val)
        {
            unsafe
            {
                fixed (byte* ptr = &this.bytes[addr])
                {
                    *(double*)ptr = val;
                }
            }
        }

        internal void StoreBytes(int addr, byte[] bytes)
        {
            Array.Copy(bytes, 0, this.bytes, addr, bytes.Length);
        }

        internal ArraySegment<byte> LoadSlice(int addr)
        {
            var array = this.LoadInt64(addr);
            var len = this.LoadInt64(addr + 8);
            return new ArraySegment<byte>(this.bytes, (int)array, (int)len);
        }

        internal ArraySegment<byte> LoadSliceDirectly(long array, int len)
        {
            return new ArraySegment<byte>(this.bytes, (int)array, len);
        }

        internal string LoadString(int addr)
        {
            var saddr = this.LoadInt64(addr);
            var len = this.LoadInt64(addr + 8);
            return Encoding.UTF8.GetString(this.bytes, (int)saddr, (int)len);
        }

        private byte[] bytes;
    }

    internal interface IImport
    {
{{- range $value := .ImportFuncs}}
{{$value.CSharp "        " false false}}{{end}}
    }

{{.JS}}

    public class Go
    {
        class Import : IImport
        {
            internal Import(Go go)
            {
                this.go = go;
            }
{{range $value := .ImportFuncs}}
{{$value.CSharp "            " true true}}{{end}}
            private Go go;
        }

        private class JSValues : JSObject.IValues
        {
            public JSValues(Go go)
            {
                this.go = go;
            }

            public object Get(string key)
            {
                switch (key)
                {
                case "_makeFuncWrapper":
                    return new JSObject((object self, object[] args) =>
                        {
                            return this.go.MakeFuncWrapper((int)JSObject.ToDouble(args[0]));
                        });
                case "_pendingEvent":
                    return this.go.pendingEvent;
                }
                throw new KeyNotFoundException(key);
            }

            public void Set(string key, object value)
            {
                switch (key)
                {
                case "_pendingEvent":
                    this.go.pendingEvent = (JSObject)value;
                    return;
                }
                throw new KeyNotFoundException(key);
            }

            public void Remove(string key)
            {
                throw new NotImplementedException();
            }

            private Go go;
        }

        public Go()
        {
            this.import = new Import(this);
            this.taskQueue = new BlockingCollection<Action>(new ConcurrentQueue<Action>());
        }

        internal object LoadValue(int addr)
        {
            double f = this.mem.LoadFloat64(addr);
            if (f == 0)
            {
                return JSObject.Undefined;
            }
            if (!double.IsNaN(f))
            {
                return f;
            }
            int id = (int)this.mem.LoadUint32(addr);
            return this.values[id];
        }

        internal void StoreValue(int addr, object v)
        {
            const int NaNHead = 0x7FF80000;
            double? d = JSObject.ToDouble(v);
            if (d.HasValue)
            {
                if (double.IsNaN(d.Value))
                {
                    this.mem.StoreInt32(addr + 4, NaNHead);
                    this.mem.StoreInt32(addr, 0);
                    return;
                }
                if (d.Value == 0)
                {
                    this.mem.StoreInt32(addr + 4, NaNHead);
                    this.mem.StoreInt32(addr, 1);
                    return;
                }
                this.mem.StoreFloat64(addr, d.Value);
                return;
            }
            if (v == JSObject.Undefined)
            {
                this.mem.StoreFloat64(addr, 0);
                return;
            }
            switch (v)
            {
            case null:
                this.mem.StoreInt32(addr + 4, NaNHead);
                this.mem.StoreInt32(addr, 2);
                return;
            case true:
                this.mem.StoreInt32(addr + 4, NaNHead);
                this.mem.StoreInt32(addr, 3);
                return;
            case false:
                this.mem.StoreInt32(addr + 4, NaNHead);
                this.mem.StoreInt32(addr, 4);
                return;
            }
            int id = 0;
            if (this.ids.ContainsKey(v))
            {
                id = this.ids[v];
            }
            else
            {
                if (this.idPool.Count > 0)
                {
                    id = this.idPool.Pop();
                }
                else
                {
                    id = this.values.Count;
                }
                this.values[id] = v;
                this.goRefCounts[id] = 0;
                this.ids[v] = id;
            }
            this.goRefCounts[id]++;
            int typeFlag = 1;
            if (v is string)
            {
                typeFlag = 2;
                // There is no counterpart for Symbol in C#, then typeFlag = 3 is not used.
            }
            else if (v is JSObject && ((JSObject)v).IsFunction)
            {
                typeFlag = 4;
            }
            this.mem.StoreInt32(addr + 4, NaNHead | typeFlag);
            this.mem.StoreInt32(addr, id);
        }

        internal object[] LoadSliceOfValues(int addr)
        {
            var array = (int)this.mem.LoadInt64(addr);
            var len = (int)this.mem.LoadInt64(addr + 8);
            var a = new object[len];
            for (int i = 0; i < len; i++)
            {
                a[i] = this.LoadValue(array + i * 8);
            }
            return a;
        }

        public void Run()
        {
            Run(new string[] { "js" });
        }

        public void Run(string[] args)
        {
            this.debugWriter = new Writer(Console.Error);
            this.stopwatch = Stopwatch.StartNew();
            this.mem = new Mem();
            this.inst = new Inst(this.mem, this.import);
            this.values = new Dictionary<int, object>
            {
                {0, double.NaN},
                {1, 0.0},
                {2, null},
                {3, true},
                {4, false},
                {5, JSObject.Global},
                {6, JSObject.Go(new JSValues(this))},
            };
            this.goRefCounts = new Dictionary<int, int>();
            this.ids = new Dictionary<object, int>();
            this.idPool = new Stack<int>();
            this.exited = false;

            int offset = 4096;
            Func<string, int> strPtr = (string str) => {
                int ptr = offset;
                byte[] bytes = Encoding.UTF8.GetBytes(str + '\0');
                this.mem.StoreBytes(offset, bytes);
                offset += bytes.Length;
                if (offset % 8 != 0)
                {
                    offset += 8 - (offset % 8);
                }
                return ptr;
            };

            // 'js' is requried as the first argument.
            args[0] = "js";
            int argc = args.Length;
            List<int> argvPtrs = new List<int>();
            foreach (string arg in args)
            {
                argvPtrs.Add(strPtr(arg));
            }
            argvPtrs.Add(0);
            // TODO: Add environment variables.
            argvPtrs.Add(0);

            int argv = offset;
            foreach (int ptr in argvPtrs)
            {
                this.mem.StoreInt32(offset, ptr);
                this.mem.StoreInt32(offset + 4, 0);
                offset += 8;
            }

            this.inst.run(argc, argv);
            for (;;)
            {
                if (this.exited)
                {
                    return;
                }
                var task = this.taskQueue.Take();
                if (task != null)
                {
                    task();
                }
            }
        }

        private void Exit(int code)
        {
            if (code != 0)
            {
                Console.Error.WriteLine($"exit code: {code}");
            }
        }

        private void Resume()
        {
            if (this.exited)
            {
                throw new Exception("Go program has already exited");
            }
            this.inst.resume();
            // Post a null task and procceed the loop.
            this.taskQueue.Add(null);
        }

        private JSObject MakeFuncWrapper(int id)
        {
            return new JSObject((object self, object[] args) =>
            {
                var evt = new JSObject(new Dictionary<string, object>()
                {
                    {"id", id},
                    {"this", self},
                    {"args", args ?? new object[0]},
                });
                this.pendingEvent = evt;
                this.Resume();
                return JSObject.ReflectGet(evt, "result");
            });
        }

        private void DebugWrite(IEnumerable<byte> bytes)
        {
            this.debugWriter.Write(bytes);
        }

        private long PreciseNowInNanoseconds()
        {
            return this.stopwatch.ElapsedTicks * nanosecPerTick;
        }

        private double UnixNowInMilliseconds()
        {
            return (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalMilliseconds;
        }

        private int SetTimeout(double interval)
        {
            var id = this.nextCallbackTimeoutId;
            this.nextCallbackTimeoutId++;

            Timer timer = new Timer(interval);
            timer.Elapsed += (sender, e) => {
                this.taskQueue.Add(() => {
                    this.Resume();
                    while (this.scheduledTimeouts.ContainsKey(id))
                    {
                        // for some reason Go failed to register the timeout event, log and try again
                        // (temporary workaround for https://github.com/golang/go/issues/28975)
                        this.Resume();
                    }
                });
            };
            timer.AutoReset = false;
            timer.Start();

            this.scheduledTimeouts[id] = timer;

            return id;
        }

        private void ClearTimeout(int id)
        {
            if (this.scheduledTimeouts.ContainsKey(id))
            {
                this.scheduledTimeouts[id].Stop();
            }
            this.scheduledTimeouts.Remove(id);
        }

        private byte[] GetRandomBytes(int length)
        {
            var bytes = new byte[length];
            this.rngCsp.GetBytes(bytes);
            return bytes;
        }

        private static long nanosecPerTick = (1_000_000_000L) / Stopwatch.Frequency;

        private Import import;

        private Writer debugWriter;
        private Stopwatch stopwatch;

        private JSObject pendingEvent;
        private Dictionary<int, Timer> scheduledTimeouts = new Dictionary<int, Timer>();
        private int nextCallbackTimeoutId = 1;
        private Inst inst;
        private Mem mem;
        private Dictionary<int, object> values;
        private Dictionary<int, int> goRefCounts;
        private Dictionary<object, int> ids;
        private Stack<int> idPool;
        private bool exited;
        private RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();

        private BlockingCollection<Action> taskQueue;
    }

    sealed class Inst
    {
        public Inst(Mem mem, IImport import)
        {
             initializeFuncs_();
             mem_ = mem;
             import_ = import;
        }

{{range $value := .Exports}}{{$value.CSharp "        "}}
{{end}}
{{range $value := .Funcs}}{{$value.CSharp "        " false true}}
{{end}}
{{range $value := .Types}}{{$value.CSharp "        "}}
{{end}}        private static readonly uint[][] table_ = {
{{range $value := .Tables}}            new uint[] { {{- range $value2 := $value}}{{$value2}}, {{end}}},
{{end}}        };

        private void initializeFuncs_()
        {
            funcs_ = new object[] {
{{range $value := .ImportFuncs}}                null,
{{end}}{{range $value := .Funcs}}                (Type{{.Type.Index}})({{.Identifier}}),
{{end}}            };
        }

{{range $value := .Globals}}{{$value.CSharp "        "}}
{{end}}
        private object[] funcs_;
        private Mem mem_;
        private IImport import_;
    }

    // The implementation is copied from the Go standard package math/bits, which is under BSD-style license.
    static class Bits
    {
        public static int LeadingZeros(uint x)
        {
            return 32 - Len(x);
        }

        public static int LeadingZeros(ulong x)
        {
            return 64 - Len(x);
        }

        public static int TailingZeros(uint x)
        {
            if (x == 0)
            {
                return 32;
            }
            return (int)deBruijn32tab[(x&-x)*deBruijn32>>(32-5)];
        }

        public static int TailingZeros(ulong x)
        {
            if (x == 0)
            {
                return 64;
            }
            return (int)deBruijn64tab[(x&(ulong)(-(long)x))*deBruijn64>>(64-6)];
        }

        public static int OnesCount(uint x)
        {
            return (int)(pop8tab[x>>24] + pop8tab[x>>16&0xff] + pop8tab[x>>8&0xff] + pop8tab[x&0xff]);
        }

        public static int OnesCount(ulong x)
        {
            const ulong m0 = 0x5555555555555555ul;
            const ulong m1 = 0x3333333333333333ul;
            const ulong m2 = 0x0f0f0f0f0f0f0f0ful;
            const ulong m  = 0xfffffffffffffffful;

            x = ((x>>1)&(m0&m)) + (x&(m0&m));
            x = ((x>>2)&(m1&m)) + (x&(m1&m));
            x = ((x>>4) + x) & (m2 & m);
            x += x >> 8;
            x += x >> 16;
            x += x >> 32;
            return (int)(x) & ((1<<7) - 1);
        }

        public static uint RotateLeft(uint x, int k)
        {
            const int n = 32;
            int s = k & (n - 1);
            return x<<s | x>>(n-s);
        }

        public static ulong RotateLeft(ulong x, int k)
        {
            const int n = 64;
            int s = k & (n - 1);
            return x<<s | x>>(n-s);
        }

        private static int Len(uint x)
        {
            int n = 0;
            if (x >= 1<<16)
            {
                x >>= 16;
                n = 16;
            }
            if (x >= 1<<8)
            {
                x >>= 8;
                n += 8;
            }
            return n + (int)len8tab[x];
        }

        private static int Len(ulong x)
        {
            int n = 0;
            if (x >= 1ul<<32)
            {
                x >>= 32;
                n = 32;
            }
            if (x >= 1ul<<16)
            {
                x >>= 16;
                n += 16;
            }
            if (x >= 1ul<<8)
            {
                x >>= 8;
                n += 8;
            }
            return n + (int)len8tab[x];
        }

        static byte[] pop8tab = new byte[] {
            0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
            0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
            0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
            0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
            0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
            0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
            0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
            0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
            0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
            0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
            0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
            0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
            0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
            0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
            0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
            0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
        };

        static byte[] len8tab = new byte[] {
            0x00, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
            0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
            0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
            0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
            0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
            0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
            0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
            0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
        };

        const uint deBruijn32 = 0x077CB531;

        static byte[] deBruijn32tab = new byte[] {
            0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
            31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9,
        };

        const ulong deBruijn64 = 0x03f79d71b4ca8b09;

        static byte[] deBruijn64tab = new byte[] {
            0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4,
            62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5,
            63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11,
            54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6,
        };
    }
}
`))
